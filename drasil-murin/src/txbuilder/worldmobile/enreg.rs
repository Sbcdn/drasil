pub mod register;
pub mod unregister;

use std::fmt;
use std::str::FromStr;

use cardano_serialization_lib::address::Address;
use cardano_serialization_lib::crypto::Ed25519KeyHash;
use cardano_serialization_lib::utils::{to_bignum, BigNum};
use cardano_serialization_lib::{AssetName, PolicyID};
use serde::{Deserialize, Serialize};

use crate::{MurinError, TransactionUnspentOutput};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct RegistrationDatum {
    /// This is the EN operator on Aya address.
    pub en_operator_address: String,
    /// This is the address of the validator node itself.
    pub en_consensus_pubkey: String,
    /// This is a tree generated by the individual EN for each epoch.
    pub en_merkle_tree_root: String,
    /// This is the cardano cross chain event address.
    pub en_cce_address: String,
    /// This the Earth Node NFT that allows to operate an EN.
    pub en_used_nft_tn: String,
    /// This is the owner wallet pub key.
    pub en_rwd_wallet: String,
    /// Commission rate given to stakers
    pub en_commission: i32,
    /// CurrencySymbol of the ENOPNFT (overwrite with hardcoded parameter to ensure is no typos)
    pub en_op_nft_cs: String,
    /// Signature created by the CCE-Address in the Datum
    /// Message is: blake2b_256 -> Concat-Bytes ( en_operator_address ++ en_consensus_pubkey ++ en_merkle_tree_root ++ en_cce_address ++ en_used_nft_tn ++ en_rwd_wallet ++ en_commission ++ en_op_nft_cs)
    pub en_signature: String,
}

/// This type represents the registration datum.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct EnRegistrationDatum {
    /// This is the EN operator on Aya address.
    pub en_operator_address: Vec<u8>,
    /// This is the address of the validator node itself.
    pub en_consensus_pubkey: Vec<u8>,
    /// This is a tree generated by the individual EN for each epoch.
    pub en_merkle_tree_root: Vec<u8>,
    /// This is the cardano cross chain event address.
    pub en_cce_address: Vec<u8>,
    /// This the Earth Node NFT that allows to operate an EN.
    pub en_used_nft_tn: AssetName,
    /// This is the owner wallet pub key.
    pub en_rwd_wallet: Ed25519KeyHash,
    /// Commission rate given to stakers
    pub en_commission: u8,
    /// CurrencySymbol of the ENOPNFT (overwrite with hardcoded parameter to ensure is no typos)
    pub en_op_nft_cs: PolicyID,
    /// Signature created by the CCE-Address in the Datum
    /// Message is: blake2b_256 -> Concat-Bytes ( en_operator_address ++ en_consensus_pubkey ++ en_merkle_tree_root ++ en_cce_address ++ en_used_nft_tn ++ en_rwd_wallet ++ en_commission ++ en_op_nft_cs)
    pub en_signature: Vec<u8>,
}

impl EnRegistrationDatum {
    pub fn from_str_datum(datum: &RegistrationDatum) -> Result<Self, MurinError> {
        Ok(EnRegistrationDatum {
            en_operator_address: hex::decode(&datum.en_operator_address)?,
            en_consensus_pubkey: hex::decode(&datum.en_consensus_pubkey)?,
            en_merkle_tree_root: hex::decode(&datum.en_merkle_tree_root)?,
            en_cce_address: hex::decode(&datum.en_cce_address)?,
            en_used_nft_tn: AssetName::from_hex(&datum.en_used_nft_tn)?,
            en_rwd_wallet: Ed25519KeyHash::from_hex(&datum.en_rwd_wallet)?,
            en_commission: datum.en_commission as u8,
            en_op_nft_cs: PolicyID::from_hex(&datum.en_op_nft_cs)?,
            en_signature: hex::decode(&datum.en_signature)?,
        })
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum RegistrationRedeemer {
    Register,
    Unregister,
}

impl ToString for RegistrationRedeemer {
    fn to_string(&self) -> String {
        match &self {
            RegistrationRedeemer::Register => "Register".to_string().to_lowercase(),
            RegistrationRedeemer::Unregister => "Unregister".to_string().to_lowercase(),
        }
    }
}

impl FromStr for RegistrationRedeemer {
    type Err = MurinError;
    fn from_str(src: &str) -> Result<Self, Self::Err> {
        let action = match src.to_lowercase().as_str() {
            "register" => RegistrationRedeemer::Register,
            "unregister" => RegistrationRedeemer::Unregister,
            _ => {
                return Err(MurinError::new(&format!(
                    "ContractAction '{src}' does not exist"
                )))
            }
        };
        Ok(action)
    }
}

impl RegistrationRedeemer {
    pub fn redeemer(&self) -> BigNum {
        match &self {
            RegistrationRedeemer::Register => to_bignum(0),
            RegistrationRedeemer::Unregister => to_bignum(1),
        }
    }
}

pub fn restore_wmreg_datum(bytes: &[u8]) -> Result<EnRegistrationDatum, MurinError> {
    let datum = cardano_serialization_lib::plutus::PlutusData::from_bytes(bytes.to_vec())
        .expect("Could not deserialize PlutusData");
    log::debug!("Restored PlutusData: {:?}", datum);
    let d_str = datum
        .to_json(cardano_serialization_lib::plutus::PlutusDatumSchema::DetailedSchema)
        .expect("Could not transform PlutusData to JSON");
    log::info!("Restored PlutusData Str: {:?}", d_str);
    let d_svalue = serde_json::from_str::<serde_json::Value>(&d_str)
        .expect("Could not transform PlutusDataJson to serde_json::Value");
    log::debug!("Deserialized Datum: \n{:?}", &d_str);
    let fields = d_svalue.get("fields").unwrap().as_array().unwrap();

    let en_operator_address = hex::decode(
        fields[0]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_consensus_pubkey = hex::decode(
        fields[1]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_merkle_tree_root = hex::decode(
        fields[2]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_cce_address = hex::decode(
        fields[3]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_used_nft_tn = AssetName::new(
        hex::decode(
            fields[4]
                .as_object()
                .unwrap()
                .get("bytes")
                .unwrap()
                .as_str()
                .unwrap(),
        )
        .unwrap(),
    )
    .unwrap();

    let en_rwd_wallet = Ed25519KeyHash::from_bytes(
        hex::decode(
            fields[5]
                .as_object()
                .unwrap()
                .get("bytes")
                .unwrap()
                .as_str()
                .unwrap(),
        )
        .unwrap(),
    )
    .unwrap();

    let en_commission = fields[6].as_u64().unwrap() as u8;

    let en_op_nft_cs = PolicyID::from_hex(
        fields[7]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_signature = hex::decode(
        fields[8]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    Ok(EnRegistrationDatum {
        en_operator_address,
        en_consensus_pubkey,
        en_merkle_tree_root,
        en_cce_address,
        en_used_nft_tn,
        en_rwd_wallet,
        en_commission,
        en_op_nft_cs,
        en_signature,
    })
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnRegistrationTxData {
    /// Wallet address.
    pub first_addr_sender_wallet: Option<Address>,
    // UTxO Containing the ENNFT
    pub ennft_utxo: Option<TransactionUnspentOutput>,
    /// The registration Datum
    pub registration_datum: EnRegistrationDatum,
}

impl fmt::Display for EnRegistrationTxData {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{},{},{}",
            if let Some(fa) = &self.first_addr_sender_wallet {
                fa.to_bech32(None).unwrap()
            } else {
                "None".to_string()
            },
            if let Some(rr) = &self.ennft_utxo {
                rr.to_hex()
            } else {
                "None".to_string()
            },
            serde_json::json!(&self.registration_datum),
        )
    }
}

impl std::str::FromStr for EnRegistrationTxData {
    type Err = MurinError;
    fn from_str(src: &str) -> Result<Self, Self::Err> {
        let split: Vec<&str> = src.split(',').collect();
        Ok(EnRegistrationTxData {
            first_addr_sender_wallet: if split[1] != "None" {
                Some(Address::from_bech32(split[1])?)
            } else {
                None
            },
            ennft_utxo: if split[2] != "None" {
                Some(TransactionUnspentOutput::from_hex(split[2])?)
            } else {
                None
            },
            registration_datum: serde_json::from_str::<EnRegistrationDatum>(split[3])?,
        })
    }
}
