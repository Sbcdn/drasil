pub(crate) mod register;
pub(crate) mod unregister;

use cardano_serialization_lib::crypto::Ed25519KeyHash;
use cardano_serialization_lib::utils::{to_bignum, BigNum};
use cardano_serialization_lib::AssetName;
use serde::{Deserialize, Serialize};

use crate::MurinError;

/// This type represents the registration datum.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct EnRegistrationDatum {
    /// This is the EN operator on Aya address.
    pub en_operator_address: Vec<u8>,
    /// This is the address of the validator node itself.
    pub en_consensus_pubkey: Vec<u8>,
    /// This is a tree generated by the individual EN for each epoch.
    pub en_merkle_tree_root: Vec<u8>,
    /// This is the cardano cross chain event address.
    pub en_cce_address: Vec<u8>,
    /// This the Earth Node NFT that allows to operate an EN.
    pub en_used_nft_tn: AssetName,
    /// This is the owner wallet pub key.
    pub en_rwd_wallet: Ed25519KeyHash,
    /// Commission rate given to stakers
    pub en_commission: u8,
    /// CurrencySymbol of the ENOPNFT (overwrite with hardcoded parameter to ensure is no typos)
    pub en_op_nft_cs: Vec<u8>,
    /// Signature created by the CCE-Address in the Datum
    /// Message is: blake2b_256 -> Concat-Bytes ( en_operator_address ++ en_consensus_pubkey ++ en_merkle_tree_root ++ en_cce_address ++ en_used_nft_tn ++ en_rwd_wallet ++ en_commission ++ en_op_nft_cs)
    pub en_signature: Vec<u8>,
}

pub enum RegistrationRedeemer {
    Register,
    Unregister,
}

impl RegistrationRedeemer {
    pub fn redeemer(&self) -> BigNum {
        match &self {
            RegistrationRedeemer::Register => to_bignum(0),
            RegistrationRedeemer::Unregister => to_bignum(1),
        }
    }
}

pub fn restore_wmreg_datum(bytes: &[u8]) -> Result<EnRegistrationDatum, MurinError> {
    let datum = cardano_serialization_lib::plutus::PlutusData::from_bytes(bytes.to_vec())
        .expect("Could not deserialize PlutusData");
    log::debug!("Restored PlutusData: {:?}", datum);
    let d_str = datum
        .to_json(cardano_serialization_lib::plutus::PlutusDatumSchema::DetailedSchema)
        .expect("Could not transform PlutusData to JSON");
    log::info!("Restored PlutusData Str: {:?}", d_str);
    let d_svalue = serde_json::from_str::<serde_json::Value>(&d_str)
        .expect("Could not transform PlutusDataJson to serde_json::Value");
    log::debug!("Deserialized Datum: \n{:?}", &d_str);
    let fields = d_svalue.get("fields").unwrap().as_array().unwrap();

    let en_operator_address = hex::decode(
        fields[0]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_consensus_pubkey = hex::decode(
        fields[1]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_merkle_tree_root = hex::decode(
        fields[2]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_cce_address = hex::decode(
        fields[3]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_used_nft_tn = AssetName::new(
        hex::decode(
            fields[4]
                .as_object()
                .unwrap()
                .get("bytes")
                .unwrap()
                .as_str()
                .unwrap(),
        )
        .unwrap(),
    )
    .unwrap();

    let en_rwd_wallet = Ed25519KeyHash::from_bytes(
        hex::decode(
            fields[5]
                .as_object()
                .unwrap()
                .get("bytes")
                .unwrap()
                .as_str()
                .unwrap(),
        )
        .unwrap(),
    )
    .unwrap();

    let en_commission = fields[6].as_u64().unwrap() as u8;

    let en_op_nft_cs = hex::decode(
        fields[7]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    let en_signature = hex::decode(
        fields[8]
            .as_object()
            .unwrap()
            .get("bytes")
            .unwrap()
            .as_str()
            .unwrap(),
    )
    .unwrap();

    Ok(EnRegistrationDatum {
        en_operator_address,
        en_consensus_pubkey,
        en_merkle_tree_root,
        en_cce_address,
        en_used_nft_tn,
        en_rwd_wallet,
        en_commission,
        en_op_nft_cs,
        en_signature,
    })
}
